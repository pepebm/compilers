Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ENDFILE
    COMPARE

Grammar

Rule 0     S' -> expression
Rule 1     expression -> expression PLUS term
Rule 2     expression -> expression MINUS term
Rule 3     expression -> term
Rule 4     term -> term TIMES factor
Rule 5     term -> term DIVIDE factor
Rule 6     program -> declaration_list
Rule 7     declaration_list -> declaration_list declaration
Rule 8     declaration_list -> declaration
Rule 9     declaration -> var_declaration
Rule 10    declaration -> fun_declaration
Rule 11    var_declaration -> type_specifier ID SEMICOLON
Rule 12    var_declaration -> type_specifier ID LBRACKET NUMBER RBRACKET SEMICOLON
Rule 13    fun_declaration -> type_specifier ID LPAREN params RPAREN compount_stmt
Rule 14    type_specifier -> INT
Rule 15    type_specifier -> VOID
Rule 16    params -> param_list
Rule 17    params -> VOID
Rule 18    param_list -> param_list COMMA param
Rule 19    param_list -> param
Rule 20    param_list -> empty
Rule 21    param -> type_specifier ID
Rule 22    param -> type_specifier ID LBRACKET RBRACKET
Rule 23    compount_stmt -> LBLOCK local_declarations statement_list RBLOCK
Rule 24    local_declarations -> local_declarations var_declaration
Rule 25    local_declarations -> empty
Rule 26    statement_list -> statement_list statement
Rule 27    statement_list -> empty
Rule 28    statement -> expression_stmt
Rule 29    statement -> compount_stmt
Rule 30    statement -> selection_stmt
Rule 31    statement -> iteration_stmt
Rule 32    statement -> return_stmt
Rule 33    expression_stmt -> expression SEMICOLON
Rule 34    expression_stmt -> SEMICOLON
Rule 35    selection_stmt -> IF LPAREN expression RPAREN statement
Rule 36    selection_stmt -> IF LPAREN expression RPAREN statement ELSE statement
Rule 37    iteration_stmt -> WHILE LPAREN expression RPAREN statement
Rule 38    return_stmt -> RETURN SEMICOLON
Rule 39    return_stmt -> RETURN expression SEMICOLON
Rule 40    expression -> var EQUAL expression
Rule 41    expression -> simple_expression
Rule 42    var -> ID
Rule 43    var -> ID LBRACKET expression RBRACKET
Rule 44    simple_expression -> additive_expression relop additive_expression
Rule 45    simple_expression -> additive_expression
Rule 46    relop -> LESS
Rule 47    relop -> LE
Rule 48    relop -> GREATER
Rule 49    relop -> GE
Rule 50    relop -> NE
Rule 51    relop -> INT
Rule 52    additive_expression -> additive_expression addop term
Rule 53    additive_expression -> term
Rule 54    addop -> PLUS
Rule 55    addop -> MINUS
Rule 56    term -> term mulop factor
Rule 57    term -> factor
Rule 58    mulop -> TIMES
Rule 59    mulop -> DIVIDE
Rule 60    factor -> LPAREN expression RPAREN
Rule 61    factor -> var
Rule 62    factor -> call
Rule 63    factor -> NUMBER
Rule 64    call -> ID LPAREN args RPAREN
Rule 65    args -> args_list
Rule 66    args -> empty
Rule 67    args_list -> args_list COMMA expression
Rule 68    args_list -> expression
Rule 69    empty -> <empty>

Terminals, with rules where they appear

COMMA                : 18 67
COMPARE              : 
DIVIDE               : 5 59
ELSE                 : 36
ENDFILE              : 
EQUAL                : 40
GE                   : 49
GREATER              : 48
ID                   : 11 12 13 21 22 42 43 64
IF                   : 35 36
INT                  : 14 51
LBLOCK               : 23
LBRACKET             : 12 22 43
LE                   : 47
LESS                 : 46
LPAREN               : 13 35 36 37 60 64
MINUS                : 2 55
NE                   : 50
NUMBER               : 12 63
PLUS                 : 1 54
RBLOCK               : 23
RBRACKET             : 12 22 43
RETURN               : 38 39
RPAREN               : 13 35 36 37 60 64
SEMICOLON            : 11 12 33 34 38 39
TIMES                : 4 58
VOID                 : 15 17
WHILE                : 37
error                : 

Nonterminals, with rules where they appear

additive_expression  : 44 44 45 52
addop                : 52
args                 : 64
args_list            : 65 67
call                 : 62
compount_stmt        : 13 29
declaration          : 7 8
declaration_list     : 6 7
empty                : 20 25 27 66
expression           : 1 2 33 35 36 37 39 40 43 60 67 68 0
expression_stmt      : 28
factor               : 4 5 56 57
fun_declaration      : 10
iteration_stmt       : 31
local_declarations   : 23 24
mulop                : 56
param                : 18 19
param_list           : 16 18
params               : 13
program              : 
relop                : 44
return_stmt          : 32
selection_stmt       : 30
simple_expression    : 41
statement            : 26 35 36 36 37
statement_list       : 23 26
term                 : 1 2 3 4 5 52 53 56
type_specifier       : 11 12 13 21 22
var                  : 40 61
var_declaration      : 9 24

Parsing method: LALR

state 0

    (0) S' -> . expression
    (1) expression -> . expression PLUS term
    (2) expression -> . expression MINUS term
    (3) expression -> . term
    (40) expression -> . var EQUAL expression
    (41) expression -> . simple_expression
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (56) term -> . term mulop factor
    (57) term -> . factor
    (42) var -> . ID
    (43) var -> . ID LBRACKET expression RBRACKET
    (44) simple_expression -> . additive_expression relop additive_expression
    (45) simple_expression -> . additive_expression
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . var
    (62) factor -> . call
    (63) factor -> . NUMBER
    (52) additive_expression -> . additive_expression addop term
    (53) additive_expression -> . term
    (64) call -> . ID LPAREN args RPAREN

    ID              shift and go to state 6
    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 4

    additive_expression            shift and go to state 7
    expression                     shift and go to state 8
    var                            shift and go to state 5
    term                           shift and go to state 1
    factor                         shift and go to state 2
    simple_expression              shift and go to state 10
    call                           shift and go to state 3

state 1

    (3) expression -> term .
    (4) term -> term . TIMES factor
    (5) term -> term . DIVIDE factor
    (56) term -> term . mulop factor
    (53) additive_expression -> term .
    (58) mulop -> . TIMES
    (59) mulop -> . DIVIDE

  ! reduce/reduce conflict for PLUS resolved using rule 3 (expression -> term .)
  ! reduce/reduce conflict for MINUS resolved using rule 3 (expression -> term .)
  ! reduce/reduce conflict for COMMA resolved using rule 3 (expression -> term .)
  ! reduce/reduce conflict for RPAREN resolved using rule 3 (expression -> term .)
  ! reduce/reduce conflict for $end resolved using rule 3 (expression -> term .)
  ! reduce/reduce conflict for RBRACKET resolved using rule 3 (expression -> term .)
    PLUS            reduce using rule 3 (expression -> term .)
    MINUS           reduce using rule 3 (expression -> term .)
    $end            reduce using rule 3 (expression -> term .)
    RBRACKET        reduce using rule 3 (expression -> term .)
    RPAREN          reduce using rule 3 (expression -> term .)
    COMMA           reduce using rule 3 (expression -> term .)
    TIMES           shift and go to state 13
    DIVIDE          shift and go to state 12
    LESS            reduce using rule 53 (additive_expression -> term .)
    LE              reduce using rule 53 (additive_expression -> term .)
    GREATER         reduce using rule 53 (additive_expression -> term .)
    GE              reduce using rule 53 (additive_expression -> term .)
    NE              reduce using rule 53 (additive_expression -> term .)
    INT             reduce using rule 53 (additive_expression -> term .)

  ! PLUS            [ reduce using rule 53 (additive_expression -> term .) ]
  ! MINUS           [ reduce using rule 53 (additive_expression -> term .) ]
  ! COMMA           [ reduce using rule 53 (additive_expression -> term .) ]
  ! RPAREN          [ reduce using rule 53 (additive_expression -> term .) ]
  ! $end            [ reduce using rule 53 (additive_expression -> term .) ]
  ! RBRACKET        [ reduce using rule 53 (additive_expression -> term .) ]

    mulop                          shift and go to state 11

state 2

    (57) term -> factor .

    TIMES           reduce using rule 57 (term -> factor .)
    DIVIDE          reduce using rule 57 (term -> factor .)
    PLUS            reduce using rule 57 (term -> factor .)
    MINUS           reduce using rule 57 (term -> factor .)
    $end            reduce using rule 57 (term -> factor .)
    RPAREN          reduce using rule 57 (term -> factor .)
    RBRACKET        reduce using rule 57 (term -> factor .)
    COMMA           reduce using rule 57 (term -> factor .)
    LESS            reduce using rule 57 (term -> factor .)
    LE              reduce using rule 57 (term -> factor .)
    GREATER         reduce using rule 57 (term -> factor .)
    GE              reduce using rule 57 (term -> factor .)
    NE              reduce using rule 57 (term -> factor .)
    INT             reduce using rule 57 (term -> factor .)


state 3

    (62) factor -> call .

    TIMES           reduce using rule 62 (factor -> call .)
    DIVIDE          reduce using rule 62 (factor -> call .)
    PLUS            reduce using rule 62 (factor -> call .)
    MINUS           reduce using rule 62 (factor -> call .)
    $end            reduce using rule 62 (factor -> call .)
    LESS            reduce using rule 62 (factor -> call .)
    LE              reduce using rule 62 (factor -> call .)
    GREATER         reduce using rule 62 (factor -> call .)
    GE              reduce using rule 62 (factor -> call .)
    NE              reduce using rule 62 (factor -> call .)
    INT             reduce using rule 62 (factor -> call .)
    RPAREN          reduce using rule 62 (factor -> call .)
    RBRACKET        reduce using rule 62 (factor -> call .)
    COMMA           reduce using rule 62 (factor -> call .)


state 4

    (63) factor -> NUMBER .

    TIMES           reduce using rule 63 (factor -> NUMBER .)
    DIVIDE          reduce using rule 63 (factor -> NUMBER .)
    PLUS            reduce using rule 63 (factor -> NUMBER .)
    MINUS           reduce using rule 63 (factor -> NUMBER .)
    $end            reduce using rule 63 (factor -> NUMBER .)
    LESS            reduce using rule 63 (factor -> NUMBER .)
    LE              reduce using rule 63 (factor -> NUMBER .)
    GREATER         reduce using rule 63 (factor -> NUMBER .)
    GE              reduce using rule 63 (factor -> NUMBER .)
    NE              reduce using rule 63 (factor -> NUMBER .)
    INT             reduce using rule 63 (factor -> NUMBER .)
    RPAREN          reduce using rule 63 (factor -> NUMBER .)
    RBRACKET        reduce using rule 63 (factor -> NUMBER .)
    COMMA           reduce using rule 63 (factor -> NUMBER .)


state 5

    (40) expression -> var . EQUAL expression
    (61) factor -> var .

    EQUAL           shift and go to state 14
    TIMES           reduce using rule 61 (factor -> var .)
    DIVIDE          reduce using rule 61 (factor -> var .)
    RPAREN          reduce using rule 61 (factor -> var .)
    PLUS            reduce using rule 61 (factor -> var .)
    MINUS           reduce using rule 61 (factor -> var .)
    LESS            reduce using rule 61 (factor -> var .)
    LE              reduce using rule 61 (factor -> var .)
    GREATER         reduce using rule 61 (factor -> var .)
    GE              reduce using rule 61 (factor -> var .)
    NE              reduce using rule 61 (factor -> var .)
    INT             reduce using rule 61 (factor -> var .)
    RBRACKET        reduce using rule 61 (factor -> var .)
    COMMA           reduce using rule 61 (factor -> var .)
    $end            reduce using rule 61 (factor -> var .)


state 6

    (42) var -> ID .
    (43) var -> ID . LBRACKET expression RBRACKET
    (64) call -> ID . LPAREN args RPAREN

    EQUAL           reduce using rule 42 (var -> ID .)
    TIMES           reduce using rule 42 (var -> ID .)
    DIVIDE          reduce using rule 42 (var -> ID .)
    PLUS            reduce using rule 42 (var -> ID .)
    MINUS           reduce using rule 42 (var -> ID .)
    $end            reduce using rule 42 (var -> ID .)
    LESS            reduce using rule 42 (var -> ID .)
    LE              reduce using rule 42 (var -> ID .)
    GREATER         reduce using rule 42 (var -> ID .)
    GE              reduce using rule 42 (var -> ID .)
    NE              reduce using rule 42 (var -> ID .)
    INT             reduce using rule 42 (var -> ID .)
    RBRACKET        reduce using rule 42 (var -> ID .)
    COMMA           reduce using rule 42 (var -> ID .)
    RPAREN          reduce using rule 42 (var -> ID .)
    LBRACKET        shift and go to state 15
    LPAREN          shift and go to state 16


state 7

    (44) simple_expression -> additive_expression . relop additive_expression
    (45) simple_expression -> additive_expression .
    (52) additive_expression -> additive_expression . addop term
    (46) relop -> . LESS
    (47) relop -> . LE
    (48) relop -> . GREATER
    (49) relop -> . GE
    (50) relop -> . NE
    (51) relop -> . INT
    (54) addop -> . PLUS
    (55) addop -> . MINUS

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RPAREN          reduce using rule 45 (simple_expression -> additive_expression .)
    COMMA           reduce using rule 45 (simple_expression -> additive_expression .)
    $end            reduce using rule 45 (simple_expression -> additive_expression .)
    RBRACKET        reduce using rule 45 (simple_expression -> additive_expression .)
    LESS            shift and go to state 20
    LE              shift and go to state 24
    GREATER         shift and go to state 18
    GE              shift and go to state 22
    NE              shift and go to state 25
    INT             shift and go to state 17
    PLUS            shift and go to state 26
    MINUS           shift and go to state 23

  ! PLUS            [ reduce using rule 45 (simple_expression -> additive_expression .) ]
  ! MINUS           [ reduce using rule 45 (simple_expression -> additive_expression .) ]

    relop                          shift and go to state 21
    addop                          shift and go to state 19

state 8

    (0) S' -> expression .
    (1) expression -> expression . PLUS term
    (2) expression -> expression . MINUS term

    PLUS            shift and go to state 28
    MINUS           shift and go to state 27


state 9

    (60) factor -> LPAREN . expression RPAREN
    (1) expression -> . expression PLUS term
    (2) expression -> . expression MINUS term
    (3) expression -> . term
    (40) expression -> . var EQUAL expression
    (41) expression -> . simple_expression
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (56) term -> . term mulop factor
    (57) term -> . factor
    (42) var -> . ID
    (43) var -> . ID LBRACKET expression RBRACKET
    (44) simple_expression -> . additive_expression relop additive_expression
    (45) simple_expression -> . additive_expression
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . var
    (62) factor -> . call
    (63) factor -> . NUMBER
    (52) additive_expression -> . additive_expression addop term
    (53) additive_expression -> . term
    (64) call -> . ID LPAREN args RPAREN

    ID              shift and go to state 6
    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 4

    additive_expression            shift and go to state 7
    expression                     shift and go to state 29
    var                            shift and go to state 5
    term                           shift and go to state 1
    factor                         shift and go to state 2
    simple_expression              shift and go to state 10
    call                           shift and go to state 3

state 10

    (41) expression -> simple_expression .

    PLUS            reduce using rule 41 (expression -> simple_expression .)
    MINUS           reduce using rule 41 (expression -> simple_expression .)
    $end            reduce using rule 41 (expression -> simple_expression .)
    RBRACKET        reduce using rule 41 (expression -> simple_expression .)
    RPAREN          reduce using rule 41 (expression -> simple_expression .)
    COMMA           reduce using rule 41 (expression -> simple_expression .)


state 11

    (56) term -> term mulop . factor
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . var
    (62) factor -> . call
    (63) factor -> . NUMBER
    (42) var -> . ID
    (43) var -> . ID LBRACKET expression RBRACKET
    (64) call -> . ID LPAREN args RPAREN

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 4
    ID              shift and go to state 6

    var                            shift and go to state 31
    factor                         shift and go to state 30
    call                           shift and go to state 3

state 12

    (5) term -> term DIVIDE . factor
    (59) mulop -> DIVIDE .
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . var
    (62) factor -> . call
    (63) factor -> . NUMBER
    (42) var -> . ID
    (43) var -> . ID LBRACKET expression RBRACKET
    (64) call -> . ID LPAREN args RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 4
    ID              shift and go to state 6

  ! LPAREN          [ reduce using rule 59 (mulop -> DIVIDE .) ]
  ! NUMBER          [ reduce using rule 59 (mulop -> DIVIDE .) ]
  ! ID              [ reduce using rule 59 (mulop -> DIVIDE .) ]

    var                            shift and go to state 31
    factor                         shift and go to state 32
    call                           shift and go to state 3

state 13

    (4) term -> term TIMES . factor
    (58) mulop -> TIMES .
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . var
    (62) factor -> . call
    (63) factor -> . NUMBER
    (42) var -> . ID
    (43) var -> . ID LBRACKET expression RBRACKET
    (64) call -> . ID LPAREN args RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 4
    ID              shift and go to state 6

  ! LPAREN          [ reduce using rule 58 (mulop -> TIMES .) ]
  ! NUMBER          [ reduce using rule 58 (mulop -> TIMES .) ]
  ! ID              [ reduce using rule 58 (mulop -> TIMES .) ]

    var                            shift and go to state 31
    factor                         shift and go to state 33
    call                           shift and go to state 3

state 14

    (40) expression -> var EQUAL . expression
    (1) expression -> . expression PLUS term
    (2) expression -> . expression MINUS term
    (3) expression -> . term
    (40) expression -> . var EQUAL expression
    (41) expression -> . simple_expression
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (56) term -> . term mulop factor
    (57) term -> . factor
    (42) var -> . ID
    (43) var -> . ID LBRACKET expression RBRACKET
    (44) simple_expression -> . additive_expression relop additive_expression
    (45) simple_expression -> . additive_expression
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . var
    (62) factor -> . call
    (63) factor -> . NUMBER
    (52) additive_expression -> . additive_expression addop term
    (53) additive_expression -> . term
    (64) call -> . ID LPAREN args RPAREN

    ID              shift and go to state 6
    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 4

    additive_expression            shift and go to state 7
    expression                     shift and go to state 34
    var                            shift and go to state 5
    term                           shift and go to state 1
    factor                         shift and go to state 2
    simple_expression              shift and go to state 10
    call                           shift and go to state 3

state 15

    (43) var -> ID LBRACKET . expression RBRACKET
    (1) expression -> . expression PLUS term
    (2) expression -> . expression MINUS term
    (3) expression -> . term
    (40) expression -> . var EQUAL expression
    (41) expression -> . simple_expression
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (56) term -> . term mulop factor
    (57) term -> . factor
    (42) var -> . ID
    (43) var -> . ID LBRACKET expression RBRACKET
    (44) simple_expression -> . additive_expression relop additive_expression
    (45) simple_expression -> . additive_expression
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . var
    (62) factor -> . call
    (63) factor -> . NUMBER
    (52) additive_expression -> . additive_expression addop term
    (53) additive_expression -> . term
    (64) call -> . ID LPAREN args RPAREN

    ID              shift and go to state 6
    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 4

    additive_expression            shift and go to state 7
    expression                     shift and go to state 35
    var                            shift and go to state 5
    term                           shift and go to state 1
    factor                         shift and go to state 2
    simple_expression              shift and go to state 10
    call                           shift and go to state 3

state 16

    (64) call -> ID LPAREN . args RPAREN
    (65) args -> . args_list
    (66) args -> . empty
    (67) args_list -> . args_list COMMA expression
    (68) args_list -> . expression
    (69) empty -> .
    (1) expression -> . expression PLUS term
    (2) expression -> . expression MINUS term
    (3) expression -> . term
    (40) expression -> . var EQUAL expression
    (41) expression -> . simple_expression
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (56) term -> . term mulop factor
    (57) term -> . factor
    (42) var -> . ID
    (43) var -> . ID LBRACKET expression RBRACKET
    (44) simple_expression -> . additive_expression relop additive_expression
    (45) simple_expression -> . additive_expression
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . var
    (62) factor -> . call
    (63) factor -> . NUMBER
    (52) additive_expression -> . additive_expression addop term
    (53) additive_expression -> . term
    (64) call -> . ID LPAREN args RPAREN

    RPAREN          reduce using rule 69 (empty -> .)
    ID              shift and go to state 6
    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 4

    factor                         shift and go to state 2
    empty                          shift and go to state 36
    term                           shift and go to state 1
    call                           shift and go to state 3
    additive_expression            shift and go to state 7
    args                           shift and go to state 37
    expression                     shift and go to state 38
    var                            shift and go to state 5
    simple_expression              shift and go to state 10
    args_list                      shift and go to state 39

state 17

    (51) relop -> INT .

    LPAREN          reduce using rule 51 (relop -> INT .)
    NUMBER          reduce using rule 51 (relop -> INT .)
    ID              reduce using rule 51 (relop -> INT .)


state 18

    (48) relop -> GREATER .

    LPAREN          reduce using rule 48 (relop -> GREATER .)
    NUMBER          reduce using rule 48 (relop -> GREATER .)
    ID              reduce using rule 48 (relop -> GREATER .)


state 19

    (52) additive_expression -> additive_expression addop . term
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (56) term -> . term mulop factor
    (57) term -> . factor
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . var
    (62) factor -> . call
    (63) factor -> . NUMBER
    (42) var -> . ID
    (43) var -> . ID LBRACKET expression RBRACKET
    (64) call -> . ID LPAREN args RPAREN

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 4
    ID              shift and go to state 6

    var                            shift and go to state 31
    term                           shift and go to state 40
    factor                         shift and go to state 2
    call                           shift and go to state 3

state 20

    (46) relop -> LESS .

    LPAREN          reduce using rule 46 (relop -> LESS .)
    NUMBER          reduce using rule 46 (relop -> LESS .)
    ID              reduce using rule 46 (relop -> LESS .)


state 21

    (44) simple_expression -> additive_expression relop . additive_expression
    (52) additive_expression -> . additive_expression addop term
    (53) additive_expression -> . term
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (56) term -> . term mulop factor
    (57) term -> . factor
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . var
    (62) factor -> . call
    (63) factor -> . NUMBER
    (42) var -> . ID
    (43) var -> . ID LBRACKET expression RBRACKET
    (64) call -> . ID LPAREN args RPAREN

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 4
    ID              shift and go to state 6

    additive_expression            shift and go to state 42
    factor                         shift and go to state 2
    var                            shift and go to state 31
    term                           shift and go to state 41
    call                           shift and go to state 3

state 22

    (49) relop -> GE .

    LPAREN          reduce using rule 49 (relop -> GE .)
    NUMBER          reduce using rule 49 (relop -> GE .)
    ID              reduce using rule 49 (relop -> GE .)


state 23

    (55) addop -> MINUS .

    LPAREN          reduce using rule 55 (addop -> MINUS .)
    NUMBER          reduce using rule 55 (addop -> MINUS .)
    ID              reduce using rule 55 (addop -> MINUS .)


state 24

    (47) relop -> LE .

    LPAREN          reduce using rule 47 (relop -> LE .)
    NUMBER          reduce using rule 47 (relop -> LE .)
    ID              reduce using rule 47 (relop -> LE .)


state 25

    (50) relop -> NE .

    LPAREN          reduce using rule 50 (relop -> NE .)
    NUMBER          reduce using rule 50 (relop -> NE .)
    ID              reduce using rule 50 (relop -> NE .)


state 26

    (54) addop -> PLUS .

    LPAREN          reduce using rule 54 (addop -> PLUS .)
    NUMBER          reduce using rule 54 (addop -> PLUS .)
    ID              reduce using rule 54 (addop -> PLUS .)


state 27

    (2) expression -> expression MINUS . term
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (56) term -> . term mulop factor
    (57) term -> . factor
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . var
    (62) factor -> . call
    (63) factor -> . NUMBER
    (42) var -> . ID
    (43) var -> . ID LBRACKET expression RBRACKET
    (64) call -> . ID LPAREN args RPAREN

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 4
    ID              shift and go to state 6

    var                            shift and go to state 31
    term                           shift and go to state 43
    factor                         shift and go to state 2
    call                           shift and go to state 3

state 28

    (1) expression -> expression PLUS . term
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (56) term -> . term mulop factor
    (57) term -> . factor
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . var
    (62) factor -> . call
    (63) factor -> . NUMBER
    (42) var -> . ID
    (43) var -> . ID LBRACKET expression RBRACKET
    (64) call -> . ID LPAREN args RPAREN

    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 4
    ID              shift and go to state 6

    var                            shift and go to state 31
    term                           shift and go to state 44
    factor                         shift and go to state 2
    call                           shift and go to state 3

state 29

    (60) factor -> LPAREN expression . RPAREN
    (1) expression -> expression . PLUS term
    (2) expression -> expression . MINUS term

    RPAREN          shift and go to state 45
    PLUS            shift and go to state 28
    MINUS           shift and go to state 27


state 30

    (56) term -> term mulop factor .

    TIMES           reduce using rule 56 (term -> term mulop factor .)
    DIVIDE          reduce using rule 56 (term -> term mulop factor .)
    PLUS            reduce using rule 56 (term -> term mulop factor .)
    MINUS           reduce using rule 56 (term -> term mulop factor .)
    $end            reduce using rule 56 (term -> term mulop factor .)
    RPAREN          reduce using rule 56 (term -> term mulop factor .)
    RBRACKET        reduce using rule 56 (term -> term mulop factor .)
    COMMA           reduce using rule 56 (term -> term mulop factor .)
    LESS            reduce using rule 56 (term -> term mulop factor .)
    LE              reduce using rule 56 (term -> term mulop factor .)
    GREATER         reduce using rule 56 (term -> term mulop factor .)
    GE              reduce using rule 56 (term -> term mulop factor .)
    NE              reduce using rule 56 (term -> term mulop factor .)
    INT             reduce using rule 56 (term -> term mulop factor .)


state 31

    (61) factor -> var .

    TIMES           reduce using rule 61 (factor -> var .)
    DIVIDE          reduce using rule 61 (factor -> var .)
    PLUS            reduce using rule 61 (factor -> var .)
    MINUS           reduce using rule 61 (factor -> var .)
    $end            reduce using rule 61 (factor -> var .)
    LESS            reduce using rule 61 (factor -> var .)
    LE              reduce using rule 61 (factor -> var .)
    GREATER         reduce using rule 61 (factor -> var .)
    GE              reduce using rule 61 (factor -> var .)
    NE              reduce using rule 61 (factor -> var .)
    INT             reduce using rule 61 (factor -> var .)
    RPAREN          reduce using rule 61 (factor -> var .)
    RBRACKET        reduce using rule 61 (factor -> var .)
    COMMA           reduce using rule 61 (factor -> var .)


state 32

    (5) term -> term DIVIDE factor .

    TIMES           reduce using rule 5 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 5 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 5 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 5 (term -> term DIVIDE factor .)
    $end            reduce using rule 5 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 5 (term -> term DIVIDE factor .)
    RBRACKET        reduce using rule 5 (term -> term DIVIDE factor .)
    COMMA           reduce using rule 5 (term -> term DIVIDE factor .)
    LESS            reduce using rule 5 (term -> term DIVIDE factor .)
    LE              reduce using rule 5 (term -> term DIVIDE factor .)
    GREATER         reduce using rule 5 (term -> term DIVIDE factor .)
    GE              reduce using rule 5 (term -> term DIVIDE factor .)
    NE              reduce using rule 5 (term -> term DIVIDE factor .)
    INT             reduce using rule 5 (term -> term DIVIDE factor .)


state 33

    (4) term -> term TIMES factor .

    TIMES           reduce using rule 4 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 4 (term -> term TIMES factor .)
    PLUS            reduce using rule 4 (term -> term TIMES factor .)
    MINUS           reduce using rule 4 (term -> term TIMES factor .)
    $end            reduce using rule 4 (term -> term TIMES factor .)
    RPAREN          reduce using rule 4 (term -> term TIMES factor .)
    RBRACKET        reduce using rule 4 (term -> term TIMES factor .)
    COMMA           reduce using rule 4 (term -> term TIMES factor .)
    LESS            reduce using rule 4 (term -> term TIMES factor .)
    LE              reduce using rule 4 (term -> term TIMES factor .)
    GREATER         reduce using rule 4 (term -> term TIMES factor .)
    GE              reduce using rule 4 (term -> term TIMES factor .)
    NE              reduce using rule 4 (term -> term TIMES factor .)
    INT             reduce using rule 4 (term -> term TIMES factor .)


state 34

    (40) expression -> var EQUAL expression .
    (1) expression -> expression . PLUS term
    (2) expression -> expression . MINUS term

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    $end            reduce using rule 40 (expression -> var EQUAL expression .)
    RBRACKET        reduce using rule 40 (expression -> var EQUAL expression .)
    RPAREN          reduce using rule 40 (expression -> var EQUAL expression .)
    COMMA           reduce using rule 40 (expression -> var EQUAL expression .)
    PLUS            shift and go to state 28
    MINUS           shift and go to state 27

  ! PLUS            [ reduce using rule 40 (expression -> var EQUAL expression .) ]
  ! MINUS           [ reduce using rule 40 (expression -> var EQUAL expression .) ]


state 35

    (43) var -> ID LBRACKET expression . RBRACKET
    (1) expression -> expression . PLUS term
    (2) expression -> expression . MINUS term

    RBRACKET        shift and go to state 46
    PLUS            shift and go to state 28
    MINUS           shift and go to state 27


state 36

    (66) args -> empty .

    RPAREN          reduce using rule 66 (args -> empty .)


state 37

    (64) call -> ID LPAREN args . RPAREN

    RPAREN          shift and go to state 47


state 38

    (68) args_list -> expression .
    (1) expression -> expression . PLUS term
    (2) expression -> expression . MINUS term

    COMMA           reduce using rule 68 (args_list -> expression .)
    RPAREN          reduce using rule 68 (args_list -> expression .)
    PLUS            shift and go to state 28
    MINUS           shift and go to state 27


state 39

    (65) args -> args_list .
    (67) args_list -> args_list . COMMA expression

    RPAREN          reduce using rule 65 (args -> args_list .)
    COMMA           shift and go to state 48


state 40

    (52) additive_expression -> additive_expression addop term .
    (4) term -> term . TIMES factor
    (5) term -> term . DIVIDE factor
    (56) term -> term . mulop factor
    (58) mulop -> . TIMES
    (59) mulop -> . DIVIDE

    LESS            reduce using rule 52 (additive_expression -> additive_expression addop term .)
    LE              reduce using rule 52 (additive_expression -> additive_expression addop term .)
    GREATER         reduce using rule 52 (additive_expression -> additive_expression addop term .)
    GE              reduce using rule 52 (additive_expression -> additive_expression addop term .)
    NE              reduce using rule 52 (additive_expression -> additive_expression addop term .)
    INT             reduce using rule 52 (additive_expression -> additive_expression addop term .)
    PLUS            reduce using rule 52 (additive_expression -> additive_expression addop term .)
    MINUS           reduce using rule 52 (additive_expression -> additive_expression addop term .)
    COMMA           reduce using rule 52 (additive_expression -> additive_expression addop term .)
    RPAREN          reduce using rule 52 (additive_expression -> additive_expression addop term .)
    $end            reduce using rule 52 (additive_expression -> additive_expression addop term .)
    RBRACKET        reduce using rule 52 (additive_expression -> additive_expression addop term .)
    TIMES           shift and go to state 13
    DIVIDE          shift and go to state 12

    mulop                          shift and go to state 11

state 41

    (53) additive_expression -> term .
    (4) term -> term . TIMES factor
    (5) term -> term . DIVIDE factor
    (56) term -> term . mulop factor
    (58) mulop -> . TIMES
    (59) mulop -> . DIVIDE

    PLUS            reduce using rule 53 (additive_expression -> term .)
    MINUS           reduce using rule 53 (additive_expression -> term .)
    $end            reduce using rule 53 (additive_expression -> term .)
    RPAREN          reduce using rule 53 (additive_expression -> term .)
    RBRACKET        reduce using rule 53 (additive_expression -> term .)
    COMMA           reduce using rule 53 (additive_expression -> term .)
    TIMES           shift and go to state 13
    DIVIDE          shift and go to state 12

    mulop                          shift and go to state 11

state 42

    (44) simple_expression -> additive_expression relop additive_expression .
    (52) additive_expression -> additive_expression . addop term
    (54) addop -> . PLUS
    (55) addop -> . MINUS

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    RPAREN          reduce using rule 44 (simple_expression -> additive_expression relop additive_expression .)
    COMMA           reduce using rule 44 (simple_expression -> additive_expression relop additive_expression .)
    $end            reduce using rule 44 (simple_expression -> additive_expression relop additive_expression .)
    RBRACKET        reduce using rule 44 (simple_expression -> additive_expression relop additive_expression .)
    PLUS            shift and go to state 26
    MINUS           shift and go to state 23

  ! PLUS            [ reduce using rule 44 (simple_expression -> additive_expression relop additive_expression .) ]
  ! MINUS           [ reduce using rule 44 (simple_expression -> additive_expression relop additive_expression .) ]

    addop                          shift and go to state 19

state 43

    (2) expression -> expression MINUS term .
    (4) term -> term . TIMES factor
    (5) term -> term . DIVIDE factor
    (56) term -> term . mulop factor
    (58) mulop -> . TIMES
    (59) mulop -> . DIVIDE

    PLUS            reduce using rule 2 (expression -> expression MINUS term .)
    MINUS           reduce using rule 2 (expression -> expression MINUS term .)
    $end            reduce using rule 2 (expression -> expression MINUS term .)
    RBRACKET        reduce using rule 2 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 2 (expression -> expression MINUS term .)
    COMMA           reduce using rule 2 (expression -> expression MINUS term .)
    TIMES           shift and go to state 13
    DIVIDE          shift and go to state 12

    mulop                          shift and go to state 11

state 44

    (1) expression -> expression PLUS term .
    (4) term -> term . TIMES factor
    (5) term -> term . DIVIDE factor
    (56) term -> term . mulop factor
    (58) mulop -> . TIMES
    (59) mulop -> . DIVIDE

    PLUS            reduce using rule 1 (expression -> expression PLUS term .)
    MINUS           reduce using rule 1 (expression -> expression PLUS term .)
    $end            reduce using rule 1 (expression -> expression PLUS term .)
    RBRACKET        reduce using rule 1 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 1 (expression -> expression PLUS term .)
    COMMA           reduce using rule 1 (expression -> expression PLUS term .)
    TIMES           shift and go to state 13
    DIVIDE          shift and go to state 12

    mulop                          shift and go to state 11

state 45

    (60) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    LESS            reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    LE              reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    GE              reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    NE              reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    INT             reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 60 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 60 (factor -> LPAREN expression RPAREN .)


state 46

    (43) var -> ID LBRACKET expression RBRACKET .

    EQUAL           reduce using rule 43 (var -> ID LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 43 (var -> ID LBRACKET expression RBRACKET .)
    DIVIDE          reduce using rule 43 (var -> ID LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 43 (var -> ID LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 43 (var -> ID LBRACKET expression RBRACKET .)
    $end            reduce using rule 43 (var -> ID LBRACKET expression RBRACKET .)
    LESS            reduce using rule 43 (var -> ID LBRACKET expression RBRACKET .)
    LE              reduce using rule 43 (var -> ID LBRACKET expression RBRACKET .)
    GREATER         reduce using rule 43 (var -> ID LBRACKET expression RBRACKET .)
    GE              reduce using rule 43 (var -> ID LBRACKET expression RBRACKET .)
    NE              reduce using rule 43 (var -> ID LBRACKET expression RBRACKET .)
    INT             reduce using rule 43 (var -> ID LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 43 (var -> ID LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 43 (var -> ID LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 43 (var -> ID LBRACKET expression RBRACKET .)


state 47

    (64) call -> ID LPAREN args RPAREN .

    TIMES           reduce using rule 64 (call -> ID LPAREN args RPAREN .)
    DIVIDE          reduce using rule 64 (call -> ID LPAREN args RPAREN .)
    LESS            reduce using rule 64 (call -> ID LPAREN args RPAREN .)
    LE              reduce using rule 64 (call -> ID LPAREN args RPAREN .)
    GREATER         reduce using rule 64 (call -> ID LPAREN args RPAREN .)
    GE              reduce using rule 64 (call -> ID LPAREN args RPAREN .)
    NE              reduce using rule 64 (call -> ID LPAREN args RPAREN .)
    INT             reduce using rule 64 (call -> ID LPAREN args RPAREN .)
    PLUS            reduce using rule 64 (call -> ID LPAREN args RPAREN .)
    MINUS           reduce using rule 64 (call -> ID LPAREN args RPAREN .)
    $end            reduce using rule 64 (call -> ID LPAREN args RPAREN .)
    RPAREN          reduce using rule 64 (call -> ID LPAREN args RPAREN .)
    RBRACKET        reduce using rule 64 (call -> ID LPAREN args RPAREN .)
    COMMA           reduce using rule 64 (call -> ID LPAREN args RPAREN .)


state 48

    (67) args_list -> args_list COMMA . expression
    (1) expression -> . expression PLUS term
    (2) expression -> . expression MINUS term
    (3) expression -> . term
    (40) expression -> . var EQUAL expression
    (41) expression -> . simple_expression
    (4) term -> . term TIMES factor
    (5) term -> . term DIVIDE factor
    (56) term -> . term mulop factor
    (57) term -> . factor
    (42) var -> . ID
    (43) var -> . ID LBRACKET expression RBRACKET
    (44) simple_expression -> . additive_expression relop additive_expression
    (45) simple_expression -> . additive_expression
    (60) factor -> . LPAREN expression RPAREN
    (61) factor -> . var
    (62) factor -> . call
    (63) factor -> . NUMBER
    (52) additive_expression -> . additive_expression addop term
    (53) additive_expression -> . term
    (64) call -> . ID LPAREN args RPAREN

    ID              shift and go to state 6
    LPAREN          shift and go to state 9
    NUMBER          shift and go to state 4

    term                           shift and go to state 1
    factor                         shift and go to state 2
    call                           shift and go to state 3
    additive_expression            shift and go to state 7
    expression                     shift and go to state 49
    var                            shift and go to state 5
    simple_expression              shift and go to state 10

state 49

    (67) args_list -> args_list COMMA expression .
    (1) expression -> expression . PLUS term
    (2) expression -> expression . MINUS term

    COMMA           reduce using rule 67 (args_list -> args_list COMMA expression .)
    RPAREN          reduce using rule 67 (args_list -> args_list COMMA expression .)
    PLUS            shift and go to state 28
    MINUS           shift and go to state 27

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 7 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 7 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 12 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 12 resolved as shift
WARNING: shift/reduce conflict for ID in state 12 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 13 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 13 resolved as shift
WARNING: shift/reduce conflict for ID in state 13 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 34 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 34 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 42 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 42 resolved as shift
WARNING: reduce/reduce conflict in state 1 resolved using rule (expression -> term)
WARNING: rejected rule (additive_expression -> term) in state 1
